#+TITLE: elmpd
#+DESCRIPTION: A tight, async mpd library 
#+DATE: <2020-09-26 Sat 18:41>
#+AUTHOR: sp1ff
#+EMAIL: sp1ff@pobox.com
#+AUTODATE: t
#+OPTIONS: toc:nil org-md-headline-style:setext *:t ^:nil

[[https://melpa.org/#/elmpd][file:https://melpa.org/packages/elmpd-badge.svg]]
[[https://stable.melpa.org/#/elmpd][file:https://stable.melpa.org/packages/elmpd-badge.svg]]

* Introduction

[[https://github.com/sp1ff/elmpd][elmpd]] is a tight, asynchronous, ergonomic [[https://www.musicpd.org/][MPD]] client library in Emacs Lisp.

This repository is work-in-progress. I've chosen the version number (0.1) in the hopes of conveying that.

* Prerequisites

Emacs 25.1.

* Installing

Install from MELPA. Tarballs are also available that can be installed through the usual =configure/make/make install= incantations.

* Getting Started

Create an MPD connection by calling =elmpd-connect=; this will return an =elmpd-connection= instance immediately. Asynchronously, it will be parsing the MPD greeting message, perhaps sending an initial password, and if so requested, sending the "idle" command.

There are two idioms I've seen in MPD client libraries for sending commands while receiving notifications of server-side changes:

    1. just maintain two connections (e.g. [[https://github.com/vincent-petithory/mpdfav][mpdfav]]); issue the "idle" command on one, send commands on the other

    2. use one connection, issue the "idle" command, and when asked to issue another command, send "noidle", issue the requested command, collect the response, and then send "idle" again (e.g. [[https://gitea.petton.fr/mpdel/libmpdel][libmpdel]]).  Note that this is not a race condition per the MPD [[https://www.musicpd.org/doc/html/protocol.html#idle][docs]] -- any server-side changes that took place while processing the command will be saved & returned on "idle"

Since =elmpd= is a library, I do not make that choice here, but rather support both styles.

The implementation is callback-based; each connection comes at the cost of a single socket plus whatever memory is needed to do the text processing in handling command responses.  In particular, I declined to use =tq= despite the natural fit because I didn't want to use a buffer for each connection, as well.

* Motivation & Design Philosphy

[[https://github.com/DamienCassou][Damien Cassou]], the author of [[https://github.com/mpdel/mpdel][mpdel]] and [[https://gitea.petton.fr/mpdel/libmpdel][libmpdel]], [[https://github.com/sp1ff/elmpd/issues/1][reached out]] to ask "Why elmpd?" His question prompted me to clarify my thoughts around this project & I've adapted my response here.

I've looked at a few [[https://www.musicpd.org/][MPD]] clients, including [[https://github.com/mpdel/mpdel][mpdel]]. As I experimented with my workflow, however, I found myself wanting _less_ functionality: rather than interacting with a fully-featured client, I just wanted to skip to the next song while editing some code, for example. I customize my mode line heavily, and I wanted a little bit of logic to add the current track to the mode line & keep it up-to-date. I have written a companion [[https://github.com/sp1ff/mpdpopm][daemon]] to MPD that maintains ratings & play counts; I just needed a little function that would let me rate the current track while I was reading mail (in Emacs, of course!)

My next move was to read through a number of client libraries for inspiration, both in C & Emacs LISP. Many of them had strong opinions on how one should talk to MPD. Having been programming MPD for a while (including simply =echo=-ing  commands to =/dev/tcp/$host/$port=), I knew this could be done simply. I spent time earlier this year learning to write asynchronous Rust, and that inspired me to see how simple I could make this using just callbacks. At the time of this writing, =elmpd= exports just two functions: =elmpd-connect= & =elmpd-send=. Each connection consumes a socket & optionally a callback-- that's it (no buffer, no transaction queue). Put another way, if other libraries are Gnus (featureful, encourages you to read your e-mail in a certain way), then elmpd is [[https://mailutils.org/][Mailutils]] (small utilities that leave it up to the user to assemble them into something useful).

* Status & Roadmap

I'm using the library day in & day out with good results. The bulk of the work has been in getting the asynchronous logic right; as such it is not very featureful. It is ripe for being used to build up a more caller-friendly API:  =(something-play)= instead of:

#+BEGIN_SRC elisp
  (let ((conn (elmpd-connect)))
    (elmpd-send conn "play"))
#+END_SRC

I'm currently working on a separate package that does that as a proof-of-concept; I will publish it if I can structure it in a generic way.
